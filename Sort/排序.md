# 排序算法
[TOC]
## 1. 原理
### 1.1 希尔排序
- [希尔排序](https://www.runoob.com/data-structures/shell-sort.html)

### 1.2 归并排序 
- [归并排序](https://www.runoob.com/data-structures/merge-sort.html)

#### 1.2.1 概念
- 归并排序(Merge sort)是建立在归并操作上的一种有效、**稳定**的排序算法，该算法是采用**分治**法(Divide and Conquer)的一个非常典型的应用。
- 时间复杂度：$O(nlogn)$
- 空间复杂度：$O(n)$
- 适用场景：数据量大对稳定性有要求。
- 稳定性：元素按照不同的元素属性进行多次排序时，能够保持元素的相对次序不变即为稳定性。比如说手机：按照销量和价格排序，两种价格不同但销量相同的手机，先按照价格排好序后再按照销量排序时要保持按照价格的顺序排序。

#### 1.2.2 原理
1. 将数组尽可能拆分为两个元素相等的子数组，并对每一个子数组继续拆分，直到拆分后的每个子数组的元素个数是1为止。
2. 将相邻的两个子数组合并为一个有序的大数组。
3. 不断重复步骤2，直到最后合并为一个数组为止。

<center>
<img src = "./picture/归并排序原理.png">
</center>

#### 1.2.3 归并排序API设计
- 类名：MergeSort
- 构造方法：MergeSort()：创建Merge对象
- 成员变量
  - private static Comparable[] assist：完成归并操作需要的辅助数组
- 成员方法

| 成员方法 | 功能 |
|:--:|:--:|
| public static void sort(Comparable[] arr) | 对数组内的元素排序 |
| private static void sort(Comparable[] arr, int low, int height) | 对数组arr中从索引low到索引height之间的元素排序 |
| private static void merge(Comparable[] arr, int low, int mid, int height) | 将索引从low到mid的子数组和索引从mid + 1到height的子数组合并成一个索引从low到height的有序数组 |
| private static boolean less(Comparable v, Comparable w) | 判断v是否小于w |


#### 1.2.4 代码实现及测试
- 归并排序实现
```java
public class MergeSort {
    //完成归并操作需要使用的辅助数组
    private static Comparable[] assist;

    //对数组arr中的元素排序
    public static void sort(Comparable[] arr) {
        assist = new Comparable[arr.length];
        int low = 0;
        int height = arr.length - 1;
        sort(arr, low, height);
    }

    //实现将数组的元素分开的操作
    private static void sort(Comparable[] arr, int low, int height) {
        if (height <= low) {
            return;
        }
        int mid = low + (height - low) / 2;
        //对low到mid之间的元素排序
        sort(arr, low, mid);
        //对mid+1到height之间的元素排序
        sort(arr, mid + 1, height);
        //对low到mid的子数组和mid+1到height的子数组归并排序
        merge(arr, low, mid, height);
    }

    private static void merge(Comparable[] arr, int low, int mid, int height) {
        int left = low; //数组arr的索引从low到mid子数组上的指针
        int right = mid + 1; //数组arr的索引从mid + 1到height子数组上的指针
        int index = low; //辅助数组assist的索引从low开始往后合并的指针

        //合并两个子数组，用两个指针分别指向两个有序数组，然后进行大小比较再合并
        while(left <= mid && right <= height) {
            if (MergeSort.less(arr[left], arr[right])) {
                assist[index++] = arr[left++];
            } else {
                assist[index++] = arr[right++];
            }
        }

        //两个while循环只会执行其中一个
        while(left <= mid) {
            assist[index++] = arr[left++];
        }
        while(right <= height) {
            assist[index++] = arr[right++];
        }

        for(int i = low; i <= height; i++) {
            arr[i] = assist[i];
        }
    }

    //比较元素v是否小于元素w
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) <= 0;
    }
}
```

- 测试
```java
    @Test
    public void MergeSortTest() {
        Integer[] arr = {8, 4, 5, 7, 1, 3, 6, 2};
        MergeSort.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
```


### 1.3 快速排序 
- [快速排序](https://www.runoob.com/data-structures/random-quick-sort.html)

#### 1.3.1 概念
- 归并排序(Merge sort)是建立在归并操作上的一种有效、**稳定**的排序算法，该算法是采用**分治**法(Divide and Conquer)的一个非常典型的应用。
- 时间复杂度：$O(nlogn)$
- 空间复杂度：$O(1)$
- 适用场景：数据量大对稳定性没有要求，不稳定的排序。

#### 1.3.2 原理
1. 首先设定一个分界值(一般选择数组第一位)。
2. 将大于等于分界值的元素放到数组右边，小于分界值的元素放到数组左边。
3. 然后左右两边的数组重复步骤1和步骤2。
4. 当左右两侧排好序后，整个数组的排序也就完成了。

<center>
<img src = "./picture/快速排序原理.png">
</center>

#### 1.3.3 快速排序API设计
- 类名：QuickSort
- 构造方法：QuickSort()：创建QuickSort对象
- 成员方法：

| 成员方法 | 功能 |
|:--:|:--:|
| public static void sort(Comparable[] arr) | 对数组内的元素排序 |
| private static void sort(Comparable[] arr, int low, int height) | 对数组arr中从索引low到索引height之间的元素排序 |
| private static int partition(Comparable[] arr, int low, int height) | 将数组arr的索引从low到height之间的元素按某个元素值分组，并返回分组界限对应的索引 |
| private static boolean less(Comparable v, Comparable w) | 判断v是否小于w |
|private static void swap(Comparable[] arr, int i, int j)|交换数组arr中索引i和索引j处的值|

#### 1.3.4 代码实现及测试
- 快排代码实现
```java
public class QuickSort {
    //对数组内元素排序
    public static void sort(Comparable[] arr) {
        int low = 0;
        int height = arr.length - 1;
        sort(arr, low, height);
    }

    //对数组从索引low到索引height之间的元素排序
    private static void sort(Comparable[] arr, int low, int height) {
        //安全性检测
        if (low >= height) {
            return;
        }
        //找到分界点的索引
        int mid = partition(arr, low, height);
        //让分界点左边有序
        sort(arr, low, mid - 1);
        //让分界点右边有序
        sort(arr, mid + 1, height);
    }

    //将数组arr的索引从low到height之间的元素按某个元素值分组，并返回分组界限对应的索引
    private static int partition(Comparable[] arr, int low, int height) {
        Comparable pivot = arr[low]; //选择标定值的元素
        int j = low; //用于维护小于标定值的元素
        for(int i = low + 1; i <= height; i++) {
            if (less(arr[i], pivot)) {
                j++;
                swap(arr, i, j);
            }
        }
        swap(arr, low, j);//将标定值交换到中间
        return j;
    }

    //判断v是否小于w
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    //交换数组arr中索引i和索引j处的值
    private static void swap(Comparable[] arr, int i, int j) {
        Comparable temp = arr[i];
        arr[i] =arr[j];
        arr[j] = temp;
    }
}
```

说明：其中最重要的部分就是确定分组界限的索引
```java
    //将数组arr的索引从low到height之间的元素按某个元素值分组，并返回分组界限对应的索引
    private static int partition(Comparable[] arr, int low, int height) {
        Comparable pivot = arr[low]; //选择标定值的元素
        int j = low; //用于维护小于标定值的元素
        for(int i = low + 1; i <= height; i++) {
            if (less(arr[i], pivot)) {
                j++;
                swap(arr, i, j);
            }
        }
        swap(arr, low, j);//将标定值交换到中间
        return j;
    }
```
- 测试
```java
    @Test
    public void QuickSort() {
        Integer[] arr = {8, 8, 5, 8, 8, 8, 8, 8};
        QuickSort.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
```

注意：
- **<font color = 'red'>快速排序时标定值的选择一定要注意随机化，否则运行会很慢</font>**。
- 循环不变量：完成一项任务，通常需要设计若干个变量。**<font color = 'red'>在循环中变量的值虽然是变化的，但是保持不变的性质就叫做循环不变量</font>**。**<font color = 'blue'>这里的不变量指的是断言即可以判断真假的语句</font>**。
- 在1）循环开始前2）循环过程中3）循环结束后，这些断言都是成立的，所以叫循环不变量。循环开始前说明一个基本情况，循环过程中说明递推情况，基本能推出循环结束后这个断言依然成立。
- **<font color = 'purple'>使用循环不变量的时候重点在于：1）说明设计的算法到底在做什么；2）说明设计的变量的作用是什么</font>**。
- 使用快速排序来说明：
    - **<font color = 'blue'>在partition()方法中索引j维护的是小于标定值的元素，在这个循环过程中要始终保持不变，最后在与low交换前都维护的是小于标定值的元素，然后将标定值与j最后所在位置交换就能保证找到标定值的索引</font>**。


### 1.4 堆排序 
#### 1.4.1 堆的基本存储
- 堆(Heap)通常是一个可以被看做一颗 **<font color = 'purple'>完全二叉树</font>** 的 **<font color = 'purple'>数组</font>** 对象。

#### 1.4.2 用数组实现的基本特点
<center>
<img src = "./picture/数组实现的堆.png">
</center>

- 将二叉树的节点按照层级顺序放入数组中，根节点在位置1，它的子节点在位置2和3，而字节点的子节点则分别在位置4，5，6，7，以次类推。
- 重要规律
  - **<font color = 'purple'>若一个节点的位置为$k$，则其父结点的位置为$k/2$(注意这是整数除法)，其两个子节点的位置分别为$2k$和$2k + 1$</font>**。这样，**<font color = 'red'>在不使用指针的情况下，我们可以通过计算数组的索引在树中上下移动：从$arr[k]$向上一层，就令$k$等于$k/2$，向下一层就令$k$等于$2k$或者$2k+1$</font>**。
  - **<font color = 'blue'>每个节点都大于等于它的两个子节点。注意：堆中仅仅规定了每个节点大于等于它的两个子节点，但两个子节点之间的大小顺序并没有做规定</font>**。
  

#### 1.4.3 堆的API设计
- 类名：Heap<T extends Comparable \<T>>
- 构造方法：Heap(int capacity)：创建容量为capacity的Heap对象
- 成员变量：
  - private T[] items：用于存储元素的数组
  - private int N：记录堆中元素的个数
- 成员方法：

| 成员方法 | 功能 |
|:--:|:--:|
|private static boolean less(int i, int j)|判断索引$i$处的元素是否小于索引$j$处的元素|
|private static void swap(int i, int j)|交换数组中索引$i$和索引$j$处的值|
|public T delMax() |删除堆中最大的元素，并返回这个最大元素|
|public void insert(T item)|往堆中插入一个元素|
|private void shiftUp(int k)|使用上浮算法，使得索引$k$处的元素能处在一个正确的位置|
|private void shiftDown(int k)|使用下沉算法，使得索引$k$处的元素能处在一个正确的位置|


#### 1.4.4 代码实现及测试
```java
public class MaxHeap<T extends Comparable<T>>{
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int count;
    //堆的容量
    private int capacity;

    //构造函数构造一个空堆，可容纳capacity个元素
    public MaxHeap(int capacity) {
        this.items = (T[]) new Comparable[capacity + 1];
        this.count = 0;
        this.capacity = capacity;
    }

    //返回堆中元素的个数
    public int size() {
        return count;
    }

    //判断堆是否为空
    public boolean isEmpty() {
        return count == 0;
    }

    //判断索引i处的元素是否小于索引j处的元素
    public boolean less(int i, int j) {
        return items[i].compareTo(items[j]) < 0;
    }

    //交换数组中索引i和索引j处的值
    private void swap(int i, int j) {
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    //往堆中插入一个元素
    public void insert(T item) {
        items[++count] = item;
        //往堆中插入新元素，只需要不断比较新节点a[k]和它的父结点a[k/2]的大小，然后根据结果完成元素的交换，就能完成堆的有序调整
        shiftUp(count);
    }

    //使用上浮算法，使得索引k处的元素能处在一个正确的位置
    private void shiftUp(int k) {
        //通过循环，不断比较当前节点的值和其父节点的值，如果发现父结点比当前节点小，则交换位置
        while(k > 1) {
            //比较当前节点和其父结点
            if (less(k/2, k)) {
                swap(k/2, k);
            }
            k = k  / 2;
        }
    }

    //使用下沉算法，使得索引k处的元素能处在一个正确的位置
    private void shiftDown(int k) {
        //通过循环，不断比较当前节点的元素和其左子节点2k和右子节点2k+1中较大元素的大小关系，如果发现当前节点比较大子节点小，则交换位置
        while(2 * k <= count) {
            //获取当前节点的子节点中较大节点
            int large; //记录较大节点所在的索引
            if(2 * k + 1 <= count) { //存在右子节点，比较左右子节点值的大小
                if (less(2*k, 2*k + 1)) {
                    large = 2 * k + 1;
                } else {
                    large = 2 * k;
                }
            } else { //不存在左右子节点，子节点中较大节点即为左子节点
                large = 2 * k;
            }
            //比较当前节点和较大子节点的值
            if (!less(k, large)) { //当前节点不小于较大子节点，堆结构正确，不用继续下沉。
                break;
            } else {
                //当前节点更小，交换当前节点的值和较大子节点的值
                swap(k, large);
                //让当前节点往下沉，继续进行判断
                k = large;
            }

        }

    }

    //删除堆中最大的元素，并返回这个最大元素
    public T delMax() {
        //大根堆中最大的元素就在根节点的位置，即索引1处
        T max = items[1];
        //1. 将根节点索引处的元素与数组中最后一个索引处的元素交换
        swap(1, count);
        //2. 让数组的最后一个索引处的元素指向一个null. 然后元素个数减一即可.这样就将最大元素从堆中删除了
        items[count] = null;
        count--;
        //3. 由于最后一个索引处的元素移到了根节点处，最大堆不能保持父结点大于等于子节点的性质了，所以要对该元素进行下沉操作
        shiftDown(1);
        return max;
    }
}
```

- 测试代码
```java
    @Test
    public void testHeap() {
        MaxHeap<String> heap = new MaxHeap<>(10);
        heap.insert("A");
        heap.insert("B");
        heap.insert("C");
        heap.insert("D");
        heap.insert("E");
        heap.insert("F");
        heap.insert("G");

        String ans = null;
        while(!heap.isEmpty()) {
            ans = heap.delMax();
            System.out.print(ans + " ");
        }
    }
```
#### 1.4.4 堆排序
- **<font color = 'purple'>在堆排序中使用不浪费空间的原地排序算法时，可以将根节点的索引设置为0，则父结点的索引为$k$时，子节点的索引为$2k + 1$和$2k+2$；子节点的索引为$k$时，父结点的索引为$(k-1)/2$</font>**。
- **<font color = 'purple'>当将根节点的索引置为0时，假设最后一个叶子节点的索引为$k$，则其父结点即为最后一个非叶子节点，父结点的索引为$(k - 1)/ 2$</font>**。
- 以构造大顶堆为数组从小到大排序为例：
    - 方法一：
      1. 对每个元素进行上浮操作，这样保证大顶堆的特性。
      2. 将最后一个索引的元素与堆顶的元素交换，这样保证最后一个索引的元素最大。
      3. 然后对堆顶的元素进行下沉操作(注意下沉的范围不考虑已经排好序的元素)，这样能维持堆的结构特点。
      4. 最后重复2，3即可。
   
   - 方法二：（更好）
      1. 对原数组中的每一个非叶子节点的元素进行下沉操作，这样能保证大顶堆的特性。
      2. 将最后一个索引的元素与堆顶元素交换，这样保证最后一个索引的元素最大。
      3. 然后对堆顶的元素进行下沉操作(注意下沉的范围不考虑已经排好序的元素)，这样能维持堆的结构特点。
      4. 最后重复2，3即可。

- 代码实现
```java
public class HeapSort {

    public void sort(Comparable[] arr) {
        int n = arr.length;
        //对每一个非叶子节点做下沉调整，保证大根堆的性质
        for (int i = (n - 1 - 1)/2; i >= 0; i--) {
            sink(arr, i, n);
        }
        //将最后一个未排好序的索引处的元素与0索引处的元素进行交换
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            sink(arr, 0, i);
        }
    }
    // 原始的sink过程
    private static void sink(Comparable[] arr, int k, int n) {

        while (2 * k + 1 < n) {
            //左孩子节点
            int j = 2 * k + 1;
            //右孩子节点比左孩子节点大
            if (j + 1 < n && arr[j + 1].compareTo(arr[j]) > 0)
                j += 1;
            //比两孩子节点都大
            if (arr[k].compareTo(arr[j]) >= 0) break;
            //交换原节点和孩子节点的值
            swap(arr, k, j);
            k = j;
        }
    }
    // 交换堆中索引为i和j的两个元素
    private static void swap(Object[] arr, int i, int j) {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
```

### 1.5 优先队列
- 优先队列的常用方法

|方法|功能|
|:--:|:--:|
|boolean offer(E e)|将指定的元素插入到此优先级队列中|
|E poll ()|检索并删除此队列的头，如果此队列为空，则返回 null|
|E peek ()|检索但不删除此队列的头，如果此队列为空，则返回 null|
|boolean isEmpty()|判断队列是否为空|
|boolean contains(Object o)|如果此队列包含指定的元素，则返回true|
|<T> T[] toArray (T[] a)|返回一个包含此队列中所有元素的数组|


## 2. leetcode之HOT100题
### 2.1 leetcode-148. 排序链表
- [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
- 时间复杂度是$O(nlogn)$的排序算法包括归并排序、快速排序和堆排序。其中，最适合链表的排序算法是归并排序。
- 原因：链表能通过修改引用来更改节点的顺序，无需像数组一样开辟额外空间。
- 归并排序的实现方式
  - 自顶向下的递归方式，递归会调用栈空间，自顶向下归并排序的空间复杂度是$O(logn)$。
  - 自底向上的实现方式的空间复杂度为$O(1)$。

#### 2.1.1 方法一：自顶向下的归并排序
<center>
<img src = "./picture/自顶向下的归并排序.png">
</center>

1. 自顶向下的归并排序的主要步骤
- 找到链表的中点，将链表分为两个子链表。寻找链表中点时使用快慢指针的方法，快指针每次移动2步，慢指针每次移动1步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表中点。
- 对两个子链表分别排序
- 将排序后的子链表按照顺序合并。
  
2. 代码实现
- 链表分割环节：
  - 使用fast，slow快慢指针方法，奇数个节点找到中点，偶数个节点找到中心左边的节点。
  - 找到中点slow后，先将slow.next赋值给mid，然后slow.next = null将链表切断，防止归并排序时整个链表进行排序。
  - 分割终止条件，当链表分割的长度小于等于1时就不需要分割了。
```java
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //将链表分割为head开头和mid开头的2条链表
        ListNode mid = slow.next;
        slow.next = null;
        //分别让左右链表有序再进行归并
        return merge(sortList(head), sortList(mid));
    }
```
说明：
1. 在使用快慢指针寻找中点时，**<font color='red'>写法是固定的，一定要牢记</font>**。

- 有序链表合并环节
```java
public ListNode merge(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode(0);
    ListNode temp = dummy;
    while(head1 != null && head2 != null) {
        if (head1.val <= head2.val) {
            temp.next = head1;
            head1 = head1.next;
        } else {
            temp.next = head2;
            head2 = head2.next;
        }
        temp = temp.next;
    }
    temp.next = head1 == null ? head2 : head1;
    return dummy.next;
}
```


#### 2.1.2 方法二：自底向上的归并排序
<center>
<img src = "./picture/自底向上的归并排序.png">
</center>

- 步骤：
1. 用subLength表示需要排序的子链表的长度，初始时为1。
2. 每次将链表拆分为若干个长度为subLength的子链表，每两个子链表合并。
3. 将subLength的值加倍，重复第2步，直到有序子链表的长度大于或等于length，整个链表排序完成。

- 代码实现

1. 自底向上归并排序
```java
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    //统计链表的长度
    int length = 0;
    ListNode node = head;
    while(node != null) {
        length++;
        node = node.next;
    }

    //引入虚拟节点，方便操作链表
    ListNode dummy = new ListNode(0, head);

    //每次将链表拆分为若干长度为subLen的子链表，并按照每两个子链表一组合并
    for(int subLen = 1; subLen < length; subLen <<= 1) {
        ListNode pre = dummy;
        ListNode cur = dummy.next; //cur用于记录拆分链表后头节点的位置

        while(cur != null) { //链表没有拆分完
            //拆分subLen长度的链表1
            ListNode head1 = cur;
            //拆分出长度为subLen的链表1，有可能最后链表的长度不足subLen，所以要加判断条件
            for (int i = 1; i < subLen && cur.next != null; i++) {
                cur = cur.next;
            }
            //拆分subLen长度的链表2

            ListNode head2 = cur.next; //第2个链表的表头，第一个链表尾部的下一个位置
            cur.next = null; //将链表1和链表2的连接断开
            cur = head2; //第2个链表开始重新赋值给cur
            //拆分出长度为subLen的链表2，有可能最后链表的长度不足subLen，所以要加判断条件
            for (int i = 1; i < subLen && cur != null && cur.next != null; i++) {
                cur = cur.next;
            }
            //再次断开第二个链表与后面链表的连接
            ListNode next = null;
            if (cur != null) {
                next = cur.next; //next用于记录链表3的头节点
                cur.next = null;
            } 

            //将链表1和链表2合并
            ListNode merged = merge(head1, head2);
            //让排好序的节点尾部指向该新排好序的链表
            pre.next = merged;
            //让pre指针移动到排好序的链表尾部，便于下一次连接
            while(pre.next != null) {
                pre = pre.next;
            }
            cur = next; //将cur指针移动到链表3的头节点，开始链表3和链表4的合并           
        }
    }
    return dummy.next;
}
```

2. 合并链表的部分与方法一的相同，就不再继续写了。

说明：
1. 学会画图，让链表的遍历过程更加清新
2. 链表断开前，要记录断开后一段的头节点，方便进行下一次循环。


### 2.2 leetcode-75. 颜色分类
- [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)
- 分析：借助快速排序算法partition过程的一趟扫描法。
- partition过程：随机选择一个元素作为切分元素(pivot)，然后经过一次扫描，将数组元素分为小于等于和大于pivot的三部分。
- 利用循环不变量来定义变量的含义
- 指针p0之前的元素都为0，指针p2之后的元素都为2
  - $[0, p0) == 0$
  - $[p0, i) == 1$
  - $(p2, len -1] == 2$
  
- 代码实现
```java
public class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        if(len < 2) {
            return;
        }
        //1.指针p0之前的元素都为0[0, p0) == 0
        //[p0, i) == 1
        //指针p2之后的元素都为2(p2, len -1] == 2
        int p0 = 0; //为了保持1的性质，开始时为空区间，p0 = 0
        int p2 = len - 1; //为了保持2的性质，开始时为空区间，p2 = len - 1
        int i = 0;
        //i 为什么可以等于p2，由于要遍历全部的元素,p2处的元素也要判断，由于p2每次都指向的是前一位，不知道这个值的取值，所以要参与循环。
        while(i <= p2) {
            if (nums[i] == 0) {
                swap(nums, p0, i);
                p0++;
                i++;
            } else if (nums[i] == 1) {
                i++;
            } else {
                swap(nums, p2, i);
                p2--;
                //从p2交换回来的元素还不知道是什么，i不需要++操作，继续判断该i。
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

- 指针p0之前的元素都为0，指针p0之后包含p0和指针p1之前的元素都为1
  - $[0, p0) == 0$
  - $[p0, p1) == 1$
  - $[p1, i) == 2$
  
- 代码实现
```java
public class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        if(len < 2) {
            return;
        }
        int p0 = 0; //保证初始时元素0的数量为0
        int p1 = 0; //保证初始时元素1的数量为0
        //保证初始时元素2的数量为0
        for(int i = 0; i < len; i++) {
            if(nums[i] == 0) {
                swap(nums, p0, i);
                if (p0 < p1 && p1 < i) { // [p0, p1)中p0处的1被换到了i处，但[p1, i)可能还有2没被换走
                    swap(nums, p1, i);
                }
                p0++;
                p1++;
            } else if(nums[i] == 1) {
                swap(nums, p1, i);
                p1++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### 2.3 leetcode-215. 数组中的第K个最大元素
- [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

#### 2.3.1 方法一：小根堆
- 思路：
  - 建一个只有$k$个元素的小根堆，堆中存放前$k$大的元素，堆顶就是第$k$个元素；在建小根堆的过程中，需要使用插入元素的操作，要对元素使用上浮操作。
  - 如果后面的元素大于堆顶元素，就将堆顶元素替换并对堆顶元素进行下沉操作即可。

- 代码实现
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        for (int i = 0; i < nums.length; i++) {
            if (i < k) {
                swim(nums, i);
            } else {
                if (nums[i] > nums[0]) {
                    nums[0] = nums[i];
                    sink(nums, 0, k);
                }
            }
        }
        return nums[0];
    }

    public void swim(int[] arr, int i) {
        while(i > 0 && arr[i] < arr[(i - 1) / 2]) {
            int temp = arr[i];
            arr[i] = arr[(i - 1) / 2];
            arr[(i - 1) / 2] = temp;
            i = (i - 1) / 2;
        }
    }

    public void sink(int[] arr, int i, int k) {
        while (2 * i + 1 < k) {
            int smaller = 2 * i + 1;
            if (2 * i + 2 < k && arr[2 * i + 2] <  arr[2 * i + 1]) {
                smaller = 2 * i + 2;
            }
            if (arr[smaller] < arr[i]) {
                int temp = arr[smaller];
                arr[smaller] = arr[i];
                arr[i] = temp;
                i = smaller; 
            } else {
                break;
            }
        }
    }
}
```
- 时间复杂度：$O(nlogk)$。遍历数组时间复杂度为$O(n)$，在小根堆中实现上浮或者下沉的操作时间复杂度为$O(logk)$。所以时间复杂度为$O(nlogk)$。
- 空间复杂度：$O(1)$。原地建堆不需要额外的空间。

#### 2.3.2 方法二：大根堆
- 思路：
  1. 将原始数组看作堆数组。然后对每一个非叶子节点进行下沉操作，保证大顶堆的结构特点。刚开始堆顶元素就是最大的元素。
  2. 将堆顶元素与最后一个索引的元素进行交换。为保持堆的特性，对索引0处的元素进行下沉调整。这样索引0处的元素就是第2大的元素。
  3. 重复上述过程$k$次，第$k$次交换前的元素就是第$k$个最大的元素。
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        for (int i = (nums.length - 1 - 1) / 2; i >= 0; i--) {
            sink(nums, i, nums.length);
        }
        int ans = 0;
        for (int i = 0; i < k; i++) {
            ans = nums[0];
            nums[0] = nums[nums.length - 1 - i];
            sink(nums, 0, nums.length - i - 1);
        }
        return ans;
    }

    public void sink(int[] arr, int i, int k) {
        while (2 * i + 1 < k) {
            int large = 2 * i + 1;
            if (2 * i + 2 < k && arr[2 * i + 2] >  arr[2 * i + 1]) {
                large = 2 * i + 2;
            }
            if (arr[large] > arr[i]) {
                int temp = arr[large];
                arr[large] = arr[i];
                arr[i] = temp;
                i = large; 
            } else {
                break;
            }
        }
    }
}
```
- 时间复杂度：$O(nlogn)$。遍历数组时间复杂度为$O(n/2) = O(n)$，在小根堆中实现下沉的操作时间复杂度为$O(logn)$。所以时间复杂度为$O(nlogn)$。
- 空间复杂度：$O(1)$。原地建堆不需要额外的空间。


#### 2.3.3 方法三：快速选择排序
- **<font color = 'blue'>快速排序的划分过程：从子数组$a[left,...,right]$中任意选择一个元素$x$作为分界点，调整子数组的元素是的左边的元素都小于等于它，右边的元素都大于等于它，则元素$x$的最终位置就是$q$</font>**。
- 思路：**<font color = 'purple'>在对子数组划分的过程中，如果划分的下标pivot正好就是我们需要的下标，就直接返回arr[pivot]；如果pivot比目标下标小，就递归右子区间，否则递归左子区间，这样就将快速排序原来递归两个区间变成只递归一个区间，提高了时间效率</font>**。
- 注意：**<font color = 'red'>一定要引入随机化选择pivot来加速这个选择过程，算法导论中有讲</font>**。

```java
class Solution {
    Random rand = new Random();
    public int findKthLargest(int[] nums, int k) {
        return findPartition(nums, 0 , nums.length - 1, k);
    }

    public int  findPartition(int[] arr, int low, int height, int k) {
        //找到分界点
        int pivot = partition(arr, low, height);
        if (pivot == arr.length - k) {
            return arr[pivot];
        } else if (pivot < arr.length - k) {
            return findPartition(arr, pivot + 1, height, k);
        } else {
            return findPartition(arr, low, pivot - 1, k);
        }
    }

    public int partition(int[] arr, int low, int height) {
        int randomIndex = rand.nextInt(height - low + 1) + low;
        swap(arr, low, randomIndex);
        int pivot = arr[low];
        int j = low;
        for(int i = low + 1; i <= height; i++) {
            if (arr[i] < pivot) {
                j++;
                swap(arr, i, j);
            }
        }
        swap(arr, low, j);
        return j;
    }

    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
- 时间复杂度：$O(n)$。
- 空间复杂度：$O(logn)$。递归使用栈空间。
- 优化：不使用栈递归调用，直接使用while循环。

```java
    public int  findPartition(int[] arr, int low, int height, int k) {
        while(true) {
            //找到分界点
            int pivot = partition(arr, low, height);
            if (pivot == arr.length - k) {
                return arr[pivot];
            } else if (pivot < arr.length - k) {
                low = pivot + 1;
            } else {
                height = pivot - 1;
            }
        }       
    }
```

### 2.4 leetcode-347. 前 K 个高频元素
- [347. 前 K 个高频元素](https://leetcode-cn.com/problem-list/2cktkvj/) 
#### 2.4.1 方法一：优先队列
- 思路：
  - 使用二元数组存储元素和其出现的频次，使用优先队列建立容量为$k$的最小堆，先存储$k$个元素，然后将频次最小的元素守门，如果后面的元素频次大于该元素，就将该元素删除，将后面的元素加入优先队列中，直至将HashMap遍历完成。
- 代码实现
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[1] - o2[1];
            }
        });
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int num = entry.getKey();
            int count = entry.getValue();
            if (pq.size() == k) {    
                if (pq.peek()[1] < count) {
                    pq.poll();
                    pq.offer(new int[]{num, count});
                }
            } else {
                pq.offer(new int[]{num, count});
            }
        }
        int[] ans = new int[k];
        for (int i = 0; i < k; i++) {
            ans[i] = pq.poll()[0];
        }
        return ans; 
    }
}
```

说明：
- **<font color = 'purple'>在使用优先队列实现Comparator比较器接口时，泛型中一定要添加PriorityQueue中存储的类型。即new Comparator<>的<>中的类型一定不能少</font>**。 
- 接口的重写方法
  - **<font color = 'red'>java.lang.Comparable\<T>接口中的方法是compareTo(Object o)</font>**
  - **<font color = 'red'>java.util.comparator\<T>接口中的方法是compare(Object o1, Object o2)</font>**
- **<font color = 'blue'>Map.Entry<Integer, Integer> entry : map.entrySet()的遍历方式一定不能忘记添加Entry<>的<>中的泛型，否则会认为entry.getKey()和entry.getValue()是Object对象，需要添加(int)才能转化为int类型，而Integer可以直接转化为int类型</font>**。
- Java在创建数组时，一定要注意 **<font color = 'red'>new int[]{num, count}</font>** 这种赋值方式。

#### 2.4.2 方法二：小顶堆
- 思路：
  - 使用二元数组存储元素和其出现的频次。
  - 自己实现建立容量为$k$的最小堆，先存储$k$个元素。然后对非叶子节点的元素进行下沉操作。将频次最小的元素置于堆顶。
  - 如果后面的元素频次大于堆顶元素，就将堆顶元素替换，然后对堆顶元素进行下沉操作直至遍历完map集合即可。

- 代码实现
```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public int[] topKFrequent(int[] nums, int k) {       
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        int[] heap = new int[k];
        int count = 0;
        for (Integer key : map.keySet()) {
            if (count < k) {
                heap[count] = key;
                count++;
                if (count == k) {
                    for(int i = (k - 1 -1) /2; i >= 0; i--) {
                        sink(heap, i, k);
                    }
                }
            } else {
                if (map.get(key) > map.get(heap[0])) {
                    heap[0] = key;
                    sink(heap, 0, k);
                }
            }
        }
        return heap;
    }
    
    public void sink(int[] arr, int i, int n) {
        while(2 * i + 1 < n) {
            int smaller = 2 * i + 1;
            if (2 * i + 2 < n && map.get(arr[2 * i + 2]) < map.get(arr[smaller])) {
                smaller++;
            }
            if (map.get(arr[smaller]) >= map.get(arr[i])) {
                break;
            } else {
                swap(arr, i, smaller);
                i = smaller;
            }
        }
    }

    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
说明：
- **<font color = 'purple'>在堆排序中使用不浪费空间的原地排序算法时，可以将根节点的索引设置为0，则父结点的索引为$k$时，子节点的索引为$2k + 1$和$2k+2$；子节点的索引为$k$时，父结点的索引为$(k-1)/2$</font>**。
- **<font color = 'purple'>当将根节点的索引置为0时，假设最后一个叶子节点的索引为$k$，则其父结点即为最后一个非叶子节点，父结点的索引为$(k - 1)/ 2$</font>**。
- **<font color = 'purple'>对未满足堆的结构的数组在实现堆结构时，直接从最后一个非叶子节点开始到堆顶的节点进行下沉即可保证堆结构，不需要对每个元素进行上浮操作。上浮操作一般只用于某个元素的插入</font>**。


#### 2.4.3 方法三：快速选择排序
- 思路：快速排序的关键问题在于确定分界点的索引。既然要寻找前$k$个频次最大元素，按频次的先后顺序找到索引为$length - k$的元素即为前$k$个元素。
- 代码实现
```java
class Solution {
    Random rand = new Random();
    Map<Integer, Integer> map = new HashMap<>();
    public int[] topKFrequent(int[] nums, int k) {       
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        int n = map.size();
        int[] arr = new int[n];
        int count = 0;
        for (Integer key : map.keySet()) {
            arr[count++] = key;
        }
        int low = 0;
        int height = n - 1;
        while(true) {
            int index = partition(arr, low, height);
            if (index == n - k) {
                return Arrays.copyOfRange(arr, n - k, n);
            } else if(index < n - k) {
                low = index + 1;
            } else {
                height = index - 1;
            }
        }
    }

    public int partition(int[] arr, int low, int height) {
        if (height > low) {
            int randomIndex = rand.nextInt(height - low + 1) + low;//随机化分界值
            swap(arr, low, randomIndex);
        }
        int pivot = arr[low];
        int j = low;
        for (int i = low + 1; i <= height; i++) {
            if (map.get(arr[i]) < map.get(arr[low])) {
                j++;
                swap(arr, i, j);
            }
        }
        swap(arr, low, j);
        return j;
    }


    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 2.5 leetcode-581. 最短无序连续子数组
- [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

<center>
<img src = "./picture/最短无序连续子数组.png">
</center>

- 思路：
  - 将数组分为三段子数组，分别记为$nums_A, nums_B, nums_C$。$nums_B$即为无序数组的部分。假设$nums_B$在$nums$中对应的区间为$[left, right]$。
  - 目标是找到中段$nums_B$的左右边界$left$和$right$。
  - 从左到右维护一个最大值$maxn$，如果索引进入右段，则没有比之前维护的最大值$maxn$小的数，所以最后一个比前面维护的最大值$maxn$更小的数就是中段的右边界$right$。
  - 从右往左维护一个最小值$minn$，如果索引进入左段，则没有比之前维护的最小值$minn$大的数，所以最后一个比前面维护的最小值$minn$更大的元素就是中段的左边界$left$。

- 代码实现
```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int left = -1;
        int right = -1;
        int maxn = Integer.MIN_VALUE;
        int minn = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < maxn) {
                right = i;
            } else {
                maxn = nums[i];
            }
            if (nums[nums.length - 1 - i] > minn) {
                left = nums.length - 1 - i;
            } else {
                minn = nums[nums.length - 1 - i];
            }
        }
        return right == -1 ? 0 : right - left + 1;
    }
}
```


### 2.6 leetcode-621. 任务调度器
- [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)
- 思路：此题可以使用桶排序。设计桶的大小为$n + 1$，则相同的任务恰好不能放入同一个桶中，桶的个数为数量最多的任务的数量。
  - 比如等待时间$n = 2$，A任务的数量为6，建立6个桶，每个桶的容量为3。就算没有其他任务，完成任务A所需要的时间应该是 $(6 - 1) * 3 + 1 = 16$，因为最后一个桶不需要等待时间。
  - 接下来可以在每个桶内添加其他任务，但由于冷却时间被安排给其他任务，所以总的时间不变。即 总排队时间 = (桶数量 - 1) * (n + 1) + 最后一桶的任务数量。
  - 特殊情况：当冷却时间短，任务种类多时，我们可以临时扩充前面填满的桶的容量，因为任务不相同，所以根本不会有冷却时间。冷却时间已经被完全填满了。那么我们执行任务所需要的时间就是任务的数量。
- 1. 记录最大数量任务$N$，记录任务数量为$N$的任务有$x$个，即最后一个桶的任务数量为$x$，计算$num1=(N - 1) * (n + 1) + x$。
- 2. $num2 = tasks.length$
- 输出其中的较大值即可。因为假设存在空闲时间，则$num1>num2$；如果不存在空闲时间，则$num2 >= num1$

- 代码实现
```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int maxCount = 0;
        int[] counts = new int[26];
        for (char ch : tasks) {
            counts[ch - 'A']++;
            maxCount = Math.max(counts[ch - 'A'], maxCount);
        }
        int maxTasksCount = 0;
        for (int count : counts) {
            if (count == maxCount) {
                maxTasksCount++;
            }
        }
        return Math.max(tasks.length, (maxCount - 1) * (n + 1) + maxTasksCount);
    }
}
```

### 2.7 leetcode-49. 字母异位词分组
- [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)
- 思路：将每个字符串拆分为字符数组，然后将字符数组排序得到一个新的字符串即可判断两个字符串是否属于字母异位词。
- 代码实现
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] chs = str.toCharArray();
            Arrays.sort(chs);
            String key = new String(chs);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        List<List<String>> ans = new ArrayList<>();
        for (List<String> list : map.values()) {
            ans.add(list);
        }
        return ans;
    }
}
```
说明：
- 字符串与字符数组之间的互相转换
  - **<font color = 'purple'>字符串转字符数组：char[] chs = str.toCharArray();</font>**。
  - **<font color = 'red'>字符数组转字符串：String str = new String(chs);</font>**。
- **<font color = 'blue'>getOrDefault返回值是对象时，如果对象不存在，可以在默认值处新建一个对象</font>**。
- **<font color = 'brown'>map集合的遍历方式中，值遍历的方式不要忘记map.values()中的values要小写</font>**。


### 2.8 leetcode-56. 合并区间
- [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)
- 思路：
  - 因为可以合并的区间一定是连续的，按照每个区间的起始点的大小关系给区间排序。
  - 先将第一个区间的左右端点设置为要合并的大区间$[start, end]$。
  - 如果第二个区间的左端点$left$大于第一个区间的右端点$end$，则证明第一个区间无法合并，直接加入结果集，将第二个区间设置为要合并的区间，继续循环。否则由于排序的关系$left$只能在$[start, end]$之间。
  - 如果第二个区间的右端点$right$大于第一个区间的右端点$end$，则说明二者可以合并，将右端点$end$更新，继续循环。
  - 如果第二个区间的右端点$right$小于等于第一个区间的右端点$end$，则说明第一个区间包含第二个区间，继续循环。
  - 最后的区间由于没有下一个区间与之合并，直接加入结果集。

- 代码实现
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length < 2) {
            return intervals;
        }
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        List<int[]> list = new ArrayList<>();
        int start = intervals[0][0];
        int end = intervals[0][1];
        for(int i = 1; i < intervals.length; i++) {
            if(intervals[i][0] > end) {
                list.add(new int[]{start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            } else if (intervals[i][1] > end) {
                end = intervals[i][1];
            }
        }
        list.add(new int[]{start, end});
        return list.toArray(new int[0][0]);
    }
}
```

说明：
- **理解区间之间如何进行合并**。
- **<font color = 'purple'>二维数组中的元素比较大小：对于普通的一维数组比较大小，是每一个元素进行比较，所以Comarpator中的泛型实际上是int型。二维数组的比较是比较的每一行的第一个元素，其中二维数组的每一行都可以看成一个一维数组，所以比较的元素是一维数组，然后比较一维数组中索引0处的值即可</font>**。
- Java在创建数组时，一定要注意 **<font color = 'red'>new int[]{start, end}</font>** 这种赋值方式。
- **Object类中的toArray()方法**：
  - **<font color = 'red'>toArray(T[] t)方法一般要传入一个指定类型的数组，如果不传参数会默认为返回Object数组</font>**。
  - **<font color = 'blue'>toArray(T[] t)方法内部会自动判断传入数组的大小是否小于list中元素的个数，如果小于则会产生一个大小等于元素个数的新数组，写入数据后返回，否则写入传入的数组然后返回</font>**。
  - **<font color = 'brown'>new int[0][]指定返回数组的类型，0是为了节省空间，只需要说明返回的类型即可，不需要指明真正的长度。而且在平时我们返回int类型的空数组时，一般不使用null，null代表数组对象都没有创建，一般使用new int[0]代表创建一个int[0]类型的空数组</font>**。**<font color = 'red'>注意一定不能忘记创建对象的关键词new</font>**。


### 2.9 leetcode-253. 会议室 II
<center>
<img src = "./picture/会议室 II.png">
</center>

#### 2.9.1 方法一：差分数组模拟
- 思路：开会也可以理解为坐公交，都是占用某个资源。以题目第一组来分析
```java
intervals = [[0,30], [5,10], [15, 20]]
```
- 第一个人从0分上车，30分下车；第二个人从5分钟上车，10分钟下车；第三个人从15分钟上车，20分钟下车。问题就能转化为 **<font color = 'red'>车上最多时有几人(也就是最多需要多少会议室)</font>**
- 显然，上车时车上人数+1；下车时车上人数-1。
- 将intervals数组拆分一下
```java
上车：[0, 1], [5, 1], [15, 1]
下车：[10, -1], [20, -1], [30, -1]
```
- 然后按照顺序将上下车排好序
```java
      0----5----10----15----20----30
变化   +1   +1   -1    +1    -1    -1
人数    1    2    1     2     1     0
```

- 代码实现
```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        int n = intervals.length;
        int[][] updown = new int[n * 2][2];
        for (int i = 0; i < 2 *n; i += 2) {
            updown[i][0] = intervals[i / 2][0]; //取每个会议的开始时间
            updown[i][1] = 1; //上车，表示有会议需要占会议室(占车上的座位)
            updown[i + 1][0] = intervals[i / 2][1]; //取每个会议的结束时间
            updown[i + 1][1] = -1; //下车，表示会议结束释放会议室(释放车上座位)
        }

        Arrays.sort(updown, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                //当时间相同时，先下车然后上车，下车的排前面，而下车 = -1 < 上车 = 1,所以是o1[1] - o2[1]
                //当时间不同时，时间较早的先结算(上车或者下车)，因此是o1[0] - o2[0]
                return o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0];
            }
        });

        //模拟上下车流程，维护这个过程中的最大值
        int count = 0;
        int ans = 0;
        for (int[] arr : updown) {
            //上车或者下车
            count += arr[1];
            //得到该过程中车上最大人数
            ans = Math.max(count, ans);
        }
        return ans;
    }
}
```

#### 2.9.2 方法二：小顶堆
- 思路：
  - 按开始时间从小到大的顺序给会议排序。
  - **用优先队列存储每一个会议室(不是每一场会议)结束时间，队首元素即为最快结束的会议室**。
  - **如果当前会议的开始时间早于队首元素(会议室最快结束时间)，则说明最早结束的会议室都没有结束，没有空闲会议室，需要新开一间，就将下一场会议的结束时间加入到优先队列中，代表新开会议室的结束时间**。
  - **如果当前会议的开始时间大于等于队首元素(会议室最快结束时间)，则说明可以占用该会议室，不需要新开一间，而占用后该会议室的结束时间已经改变，所以要将队首元素弹出，将当前会议结束时间加入优先队列中，从而更新当前会议室结束时间**。
  - **最后优先队列中存储的元素的数量就是会议室的数量**。

- 代码实现
```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals.length <= 1) {
            return intervals.length;
        }
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });

        PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> o1 - o2);
        pq.offer(intervals[0][1]);
        for (int i = 1; i < intervals.length; i++) {//注意从下一会议的开始时间判断，所以i从1开始而不是从0开始
            if (intervals[i][0] >= pq.peek()) {
                pq.poll();
            }
            pq.offer(intervals[i][1]);
        }
        return pq.size();
    }
}
```
说明：**此题最好是将占用会议室与上车下车占公交车的座位相类比**。


### 2.10 leetcode-406. 根据身高重建队列
- [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)
- 思路：
- **<font color = 'red'>一般这种数对，还涉及排序的题目，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程</font>**。
  - **<font color = 'brown'>按照数对的元素1降序排序，因为按照元素1降序排序，对于每个元素，在其之前的元素个数就是大于等于它的元素数量，然后判断其与数对的元素2之间的大小关系，就能知道该在哪个位置插入。并且后面的数对由于元素1小于前面的数对，所以它往前插入对前面的数对没影响</font>**。
  - **<font color = 'purple'>按照数对的元素2升序排序，因为，在元素1相同的情况下，元素2大的必然在后面。例如：[4,2]和[4,3]。如果[4,3]在[4,2]之前，首先对于[4,3]来说前面有3个元素1不小于4的数对，[4,2]放后面说明包含[4,3]就至少有4个元素1不小于4的数对，这与[4,2]的元素2不符合，所以要按照数对的元素2升序排列</font>**。
- 代码实现
```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        //将数组按照元素1升序排排序，然后按照元素2降序排序
        Arrays.sort(people, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];
            }
        });
        //用list集合存储结果，因为list集合添加元素到指定位置相对容易，数组需要不停的移位
        List<int[]> ans = new ArrayList<>();
        for (int[] arr : people) {
            
            ans.add(arr[1], arr);
        }
        //将list集合转化为数组
        return ans.toArray(new int[0][]);
    }
}
```
说明：
- 排序功能也能通过Lambda表达式实现，具体代码如下：
```java
Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
```
- Lambda表达式的语法格式如下：
  - **不需要声明参数类型，编译器可以统一识别**
  - **一个参数无需圆括号，但多个参数需要圆括号**
  - **如果主体包含一个语句，就不需要大括号**
  - **如果主体只有一个表达式返回值，则编译器会自动返回；否则，大括号需要指定返回值**
```java
(parameters) -> expression
或
(parameters) ->{ statements; }
```
- list集合的add()方法
  - **<font color = 'purple'>list集合的添加元素和插入元素都是用add方法，但添加元素不需要索引index参数</font>**
  - **list集合插入元素方法中，<font color = 'red'>索引index参数在前面，插入元素在后面</font>**。
  - **从最后一个超范围的异常发现，list集合插入元素方法中，<font color = 'blue'>插入的索引是可以等于list.size()的</font>**。
<center>
<img src = "./picture/list集合的add方法.png">
</center>

```java
//原本的for循环
for (int i = 0; i < people.length; i++) {
    if (people[i][1] == ans.size()) {
        ans.add(people[i]);
    } else {
        ans.add(people[i][1], people[i]);
    }
}
//现在的for循环
for(int[] arr : people) {
    ans.add(arr[1], arr);
}
```
- **因为这道题目要有正确答案，将数对排好序后，那么数对的插入位置people[i][1]要么在list集合的尾部，要么在list集合中，因为后面没有数对的元素1大于当前数对的元素1。所以可以统一使用list集合的插入元素方法**。
- **<font color = 'red'>java的二维数组可以看作是由行数组组成的一维数组，所以for循环中的每一个元素都是一维行数组，arr[1]表示行数组索引1处的元素，arr代表整个行数组</font>**。
- **Object类中的toArray()方法**：
  - **<font color = 'red'>toArray(T[] t)方法一般要传入一个指定类型的数组，如果不传参数会默认为返回Object数组</font>**。
  - **<font color = 'blue'>toArray(T[] t)方法内部会自动判断传入数组的大小是否小于list中元素的个数，如果小于则会产生一个大小等于元素个数的新数组，写入数据后返回，否则写入传入的数组然后返回</font>**。
  - **<font color = 'brown'>new int[0][]指定返回数组的类型，0是为了节省空间，只需要说明返回的类型即可，不需要指明真正的长度。而且在平时我们返回int类型的空数组时，一般不使用null，null代表数组对象都没有创建，一般使用new int[0]代表创建一个int[0]类型的空数组</font>**。**<font color = 'red'>注意一定不能忘记创建对象的关键词new</font>**。

## 3. 剑指Offer
### 3.1 leetcode-剑指 Offer 45. 把数组排成最小的数
- [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
1. 思路：
- 最小数就要求前面的数越小越好。本质上是排序问题。
- 假设数组中任意两个数的字符串为$a$和$b$，则规定排序规则为：
  - 如果字符串$a + b < b + a$，则说明$a$应该放在$b$前面；
  - 如果字符串$a + b > b + a$，则说明$b$应该放在$a$前面；
2. 代码实现
```java
class Solution {
    public String minNumber(int[] nums) {
        int n = nums.length;
        String[] str = new String[n];
        for (int i = 0; i < n; i++) {
            str[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(str, (a, b) -> (a + b).compareTo(b + a));
        StringBuilder sb = new StringBuilder();
        for(String s : str) {
            sb.append(s);
        }
        return sb.toString();
    }
}
```
3. 说明：
- **<font color = 'red'>将数组转换为字符串的方法尽量使用String.valueOf()方法，使用空字符串和+号拼接的方法内存消耗以及时间消耗较大</font>**。
- **<font color = 'blue'>int compareTo()方法：</font>**
  - **<font color = 'green'>比较字符串是比较前后两个字符串的每个字母的ASCII差值</font>**
    - **<font color = 'purple'>如果两个字符串的首字母不同，则返回首字母的ASCII差值</font>**
    - **<font color = 'purple'>参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的ascII码差值</font>**
    - **<font color = 'purple'>如果两个字符串不一样长，可以参与比较的字符又完全一样，则返回两个字符串的长度差值</font>**
  - **<font color = 'brown'>数字类型不能用compareTo()方法比较，即int类型与int类型的比较，直接使用比较符号(>，<，!=，==)比较</font>**
- **<font color = 'green'>使用Lambda表达式比使用内部类的性能更好</font>**

4. 相似题目
- [179. 最大数](https://leetcode-cn.com/problems/largest-number/)
- 注意：**<font color = 'red'>此题没有说明保留前导"0"，那么就必须去除前导"0"的情况。由于求解最大值，如果字符串数组的首位为"0"，则后面比不可能大于"0"，否则会与字符串数组首位交换，所以结果必定是"0"</font>**。
- 代码实现
```java
class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] str = new String[n];
        for (int i = 0; i <n; i++) {
            str[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(str, (s1, s2) -> (s2 + s1).compareTo(s1 + s2));
        if (str[0].equals("0")) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        for (String s : str) {
            sb.append(s);
        }
        return sb.toString();
    }
}
```
